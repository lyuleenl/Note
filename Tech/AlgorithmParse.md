# 什么是 LRU 算法

就是一种缓存淘汰策略。

计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？

LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。

### **LRU 算法描述**

LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。

注意哦，get 和 put 方法必须都是 `O(1)` 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。

```java
/* 缓存容量为 2 */
LRUCache cache = new LRUCache(2);
// 你可以把 cache 理解成一个队列
// 假设左边是队头，右边是队尾
// 最近使用的排在队头，久未使用的排在队尾
// 圆括号表示键值对 (key, val)

cache.put(1, 1);
// cache = [(1, 1)]
cache.put(2, 2);
// cache = [(2, 2), (1, 1)]
cache.get(1);       // 返回 1
// cache = [(1, 1), (2, 2)]
// 解释：因为最近访问了键 1，所以提前至队头
// 返回键 1 对应的值 1
cache.put(3, 3);
// cache = [(3, 3), (1, 1)]
// 解释：缓存容量已满，需要删除内容空出位置
// 优先删除久未使用的数据，也就是队尾的数据
// 然后把新的数据插入队头
cache.get(2);       // 返回 -1 (未找到)
// cache = [(3, 3), (1, 1)]
// 解释：cache 中不存在键为 2 的数据
cache.put(1, 4);    
// cache = [(1, 4), (3, 3)]
// 解释：键 1 已存在，把原始值 1 覆盖为 4
// 不要忘了也要将键值对提前到队头
```

### **LRU 算法设计**

分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。

那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。

![img](https://gblobscdn.gitbook.com/assets%2F-MUvWpzDydpd316eAy0j%2Fsync%2F30af4fb8bfe13c9ffb55818ccb70cc57b6c0a508.jpg?alt=media)

# 全序关系和偏序关系

参考：https://www.zhihu.com/question/36758436/answer/555298363

偏序与完全序（离散数学知识）

**（1）偏序与完全序的概念：**

偏序关系、全序关系都是公理集合论中的一种二元关系。 

​	• 偏序集合：配备了偏序关系的集合。 

偏序：只对部分要元素成立关系（部分可比）

集合内只有部分元素之间在这个关系下是可以比较的。 

比如：比如复数集中并不是所有的数都可以比较大小，那么“大小”就是复数集的一个偏序关系。

​	• 全序集合：配备了全序关系的集合。

全序：对集合中任意两个元素都有关系

集合内任何一对元素在在这个关系下都是相互可比较的。 

比如：有限长度的序列按字典序是全序的。最常见的是单词在字典中是全序的。

**（2）偏序与完全序的定义:**

​	• 偏序的定义：

设R是集合A上的一个二元关系，若R满足： 

Ⅰ 自反性：对任意x∈A，有xRx； 

Ⅱ 反对称性（即反对称关系）：对任意x,y∈A，若xRy，且yRx，则x=y； 

Ⅲ 传递性：对任意x, y,z∈A，若xRy，且yRz，则xRz。 

则称R为A上的偏序关系。

​	• 全序的定义：

设集合X上有一全序关系，如果我们把这种关系用 ≤ 表述，则下列陈述对于 X 中的所有 a, b 和 c 成立： 

如果 a ≤ b 且 b ≤ a 则 a = b (反对称性) 

如果 a ≤ b 且 b ≤ c 则 a ≤ c (传递性) 

a ≤ b 或 b ≤ a (完全性)

**注意**：

完全性本身也包括了自反性。 所以，全序关系必是偏序关系。

# A*搜索算法

A* 搜索算法（A* search algorithm）是一种在图形平面上，有多个节点的路径，求出最低通过成本的算法。常用于游戏中的NPC的移动计算，或网络游戏的BOT的移动计算上。

该算法综合了最良优先搜索和Dijkstra算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（基于评估函数）。

A*算法通过下面这个函数来计算每个节点的优先级。


其中：

$f(n)=g(n)+h(n)$

f(n)是节点n的综合优先级。当我们选择下一个要遍历的节点时，我们总会选取综合优先级最高（值最小）的节点。

g(n) 是节点n距离起点的代价。

h(n)是节点n距离终点的预计代价，这也就是A*算法的启发函数。关于启发函数我们在下面详细讲解。

A*算法在运算过程中，每次从优先队列中选取f(n)值最小（优先级最高）的节点作为下一个待遍历的节点。

另外，A*算法使用两个集合来表示待遍历的节点，与已经遍历过的节点，这通常称之为open_set和close_set。

完整的A*算法描述如下：

* 初始化open_set和close_set；
* 将起点加入open_set中，并设置优先级为0（优先级最高）；
* 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中

这个公式遵循以下特性：

如果$g(n)$为0，即只计算任意顶点$n$到目标的评估函数$h(n)$，而不计算起点到顶点$n$的距离，则算法转化为使用贪心策略的最良优先搜索，速度最快，但可能得不出最优解；

如果$h(n)$不大于顶点$n$到目标顶点的实际距离，则一定可以求出最优解，而且$h(n)$越小，需要计算的节点越多，算法效率越低，常见的评估函数有——欧几里得距离、曼哈顿距离、切比雪夫距离；

如果$h(n)$为0，即只需求出起点到任意顶点$n$的最短路径$g(n)$，而不计算任何评估函数$h(n)$，则转化为单源最短路径问题，即Dijkstra算法，此时需要计算最多的顶点

参考：

https://zhuanlan.zhihu.com/p/54510444

https://zh.wikipedia.org/wiki/A%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95

https://www.gamedev.net/reference/articles/article2003.asp

